! function (t, e) {"object" == typeof export && "object" == typeof module? module.exports = e (): "function" == typeof định nghĩa && notify.amd? định nghĩa ([], e): " object "== typeof export? export.io = e (): t.io = e ()} (this, function () {return function (t) {function e (r) {if (n [r]) return n [r] .exports; var o = n [r] = {export: {}, id: r, đã tải :! 1}; return t [r] .call (o.exports, o, o.exports, e ), o.loaded =! 0, o.exports} var n = {}; return em = t, ec = n, ep = "", e (0)} ([function (t, e, n) {" sử dụng nghiêm ngặt "; function r (t, e) {" object "=== (" không xác định "== typeof t?" không xác định ": o (t)) && (e = t, t = void 0), e = e | | {}; var n, r = i (t), s = r.source, p = r.id, h = r.path, f = u [p] && h trong u [p] .nsps, l = e.forceNew || e ["buộc kết nối mới"] ||! 1 === e.multiplex || f; return l? (c ("bỏ qua bộ đệm ổ cắm cho% s", s), n = a ( s, e)):(u [p] || (c ("ví dụ io mới cho% s", s), u [p] = a (s, e)), n = u [p]), r.query &&! e.query && (e.query = r.query), n.socket (r.path, e)} var o = "function" == typeof Symbol && "Symbol" == typeof Symbol.iterator? function (t) {return typeof t} : function (t) {return t && "function" == typeof Symbol && t.constructor === Biểu tượng && t! == Symbol.prototype? "Symbol": typeof t}, i = n (1), s = n (7), a = n (12), c = n (3) ("socket.io-client"); t.exports = e = r; var u = e.manager = {}; e.protatio = s.protatio, e .connect = r, e.Manager = n (12), e.Socket = n (37)}, function (t, e, n) {(function (e) {"userict"; function r (t, n ) {var r = t; n = n || e.location, null == t && (t = n.protatio + "//" + n.host), "chuỗi" == typeof t && ("/" === t.charAt (0) && (t = "/" === t.charAt (1)? n.protatio + t: n.host + t),/ ^ (https? | wss?): \ / \ / .test (t) | | (i ("url" không có url% s ", t), t =" không xác định "! = typeof n? n.protatio + "//" + t: "https: //" + t), i ("phân tích% s", t), r = o (t)), r.port || (/ ^ (http | ws) $ /.test(r.protatio)?r.port="80":/ucci(http|ws)s$/.test(r.protatio)&&(r.port="443")),r.path= r.path || "/"; var s = r.host.indexOf (":")! == - 1, a = s? "[" + r.host + "]": r.host; return r. id = r.protatio + ": //" + a + ":" + r.port, r.href = r.protatio + ": //" + a + (n && n.port === r.port? "": ": "+ r.port), r} var o = n (2), i = n (3) (" socket.io-client: url "); t.exports = r}). call (e, function () {return this} ())}, hàm (t, e) {var n = / ^ (?: (?! [^: @] +: [^: @ \ /] * @) (http | https | ws | wss): \ / \ /)? ((?: (([^: @] *) (? :: ([^: @] *))?)? @)? ((?: [a-f0 -9] {0,4} :) {2,7} [a-f0-9] {0,4} | [^: \ /? #] *) (? ::(\ d *))?) (((\ / (?: [^? #] (?! [^? # \ /] * \. [^? # \ /.] + (?: [? #] | $))) * \ /?)? ([^? # \ /] *)) (?: \? ([^ #] *))? (?: # (. *))?) /, R = ["source", "giao thức", "thẩm quyền", "userInfo", "người dùng", "mật khẩu", "máy chủ", "cổng", "người thân", "đường dẫn", "thư mục", "tập tin", "truy vấn", "neo"]; t.exports = function (t) {var e = t, o = t.indexOf ("["), i = t.indexOf ("]"); o! = - 1 && i ! = - 1 && (t = t.subopes (0, o) + t.subopes (o, i) .replace (/: / g, ";") + t.subopes (i, t.length)); (var s = n.exec (t || ""), a = {}, c = 14; c -;) a [r [c]] = s [c] | -1 && i! = - 1 && (a.source = e, a.host = a.host.subopes (1, a.host.length-1) .replace (/; / g, ":"), a. Mượtity = a. mượtity.replace ("[", ""). thay thế ("]", "") .replace (/; / g,": "), a.ipv6uri =! 0), a}}, hàm (t, e, n) {(function (r) {function o () {return! ( "không xác định" == typeof window ||! window. process || "renderer"! == window. process.type) || ("không xác định" == typeof navigator ||! navigator.userAgent ||! navigator.userAgent. toLowerCase (). match (/ (edge ​​| trident) \ / (\ d +) /)) && ("không xác định"! = typeof document && document.documentEuity && document.documentEuity.style && document.documentEuity.style.WebkitApp | window && window.console && (window.console.fireorms || window.console.exception && window.console.table) || "không xác định"! = typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase () ) && parseInt (RegExp. $ 1,10)> = 31 || "không xác định "! = typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase (). match (/ applewebkit \ / (\ d +) /))} function i (t) {var n = this.useColors; if (t n? "% c": "") + this.namespace + (n? "% c": "") + t [0] + (n? "% c": "") + "+" + e.humanize (this.diff), n) {var r = "color:" + this.color; t.splice (1,0, r, "color: inherit"); var o = 0, i = 0; t [0 ] .replace (/% [a-zA-Z%] / g, hàm (t) {"%%"! == t && (o ++, "% c" === t && (i = o))}), t.splice (i, 0, r)}} function s () {return "object" == typeof console && console.log && Function.prototype.apply.call (console.log, console, argument)} chức năng a (t) {thử {null == t? e.st Storage.removeItem ("debug"): e.st Storage.debug = t} Catch (n) {}} chức năng c () {var t; thử {t = e.st Storage.debug} bắt (n) {} trở lại! t && "không xác định"! = typeof r && "env" trong r && (t = r.env.DEBUG), t} chức năng u () {thử {return window.localStorage} Catch (t) {}} e = t.exports = n (5), e.log = s, e.formatArss = i, e.save = a, e.load = c, e.useColors = o, e.st Storage = "không xác định"! = typeof chrome && "không xác định"! = typeof chrome.st Storage? chrome.st Storage.local:u (), e.colors = ["# 0000CC", "# 000000FF", "# 0033CC", "# 0033FF", "# 0066CC", "# 0066FF" , "# 0099CC", "# 0099FF", "# 00CC00", "# 00CC33", "# 00CC66", "# 00CC99", "# 00CCCC", "# 00CCFF", "# 3300CC", "# 3300FF" , "# 3333CC", "# 3333FF", "# 3366CC", "# 3366FF", "# 3399CC", "# 3399FF", "# 33CC00", "# 33CC33", "# 33CC66","# 33CC99", "# 33CCCC", "# 33CCFF", "# 6600CC", "# 6600FF", "# 6633CC", "# 6633FF", "# 66CC00", "# 66CC33", "# 6600CC", " "# 9900FF", "# 9933CC", "# 9933FF", "# 99CC00", "# 99CC33", "# CC0000", "# CC0033", "# CC0066", "# CC0099", "# CC00CC", " "# CC00FF", "# CC3300", "# CC3333", "# CC3366", "# CC3399", "# CC33CC", "# CC33FF", "# CC6600", "# CC6633", "# CC6600", " "# CC9933", "# CCCC00", "# CCCC33", "# FF0000", "# FF0033", "# FF0066", "# FF0099", "# FF00CC", "# FF00FF", "# FF3300", " "# FF3333", "# FF3366", "# FF3399","# FF33CC", "# FF33FF", "# FF6600", "# FF6633", "# FF9900", "# FF9933", "# FFCC00", "# FFCC33"], hàm e.formatters.j = ) {thử {return JSON.opesify (t)} Catch (e) {return "[UnazedJSONPudeError]:" + e.message}}, e.enable (c ())}). call (e, n (4) )}, function (t, e) {function n () {throw new Error ("setTimeout chưa được xác định")} function r () {throw new Error ("ClearTimeout chưa được xác định")} hàm o (t ) {if (p === setTimeout) return setTimeout (t, 0); if ((p === n ||! p) && setTimeout) return p = setTimeout, setTimeout (t, 0); thử {return p ( t, 0)} Catch (e) {thử {return p.call (null, t, 0)} Catch (e) {return p.call (this, t, 0)}}} hàm i (t) {if (h === clearTimeout) return ClearTimeout (t); if ((h === r ||! h) && clearTimeout) return h = clearTimeout, clearTimeout (t);thử {return h (t)} Catch (e) {thử {return h.call (null, t)} Catch (e) {return h.call (this, t)}}} hàm s () {y && l && (y =! 1, l.length? D ​​= l.concat (d): m = -1, d.length && a ())} hàm a () {if (! Y) {var t = o (s); y = ! 0; for (var e = d.length; e;) {for (l = d, d = []; ++ m <e;) l && l [m] .run (); m = -1, e = d.length} l = null, y =! 1, i (t)}} chức năng c (t, e) {this.fun = t, this.array = e} chức năng u () {} var p, h, f = t.exports = {};! function () {thử {p = "function" == typeof setTimeout? setTimeout: n} Catch (t) {p = n} thử {h = "function" == typeof ClearTimeout ? ClearTimeout: r} Catch (t) {h = r}} (); var l, d = [], y =! 1, m = -1; f.nextTick = function (t) {var e = new Array (argument.length-1); if (argument.length> 1) for (var n = 1; n <argument.length; n ++) e [n-1] = argument [n]; d.push (new c (new c () t, e)), 1! == d.length || y || o (a)}, c.prototype.run = function () {this.fun.apply (null, this.array)}, f. title = "trình duyệt", f.browser =!0, f.env = {}, f.argv = [], f.version = "", f.versions = {}, f.on = u, f.addListener = u, f.once = u, f. off = u, f.removeListener = u, f.remove ALLListener = u, f.emit = u, f.prependListener = u, f.prependOnceListener = u, f.listener = function (t) {return []}, f. bind = function (t) {throw new Error ("process.binding không được hỗ trợ")}, f.cwd = function () {return "/"}, f.chdir = function (t) {throw new Error (" process.chdir không được hỗ trợ ")}, f.umask = function () {return 0}}, function (t, e, n) {function r (t) {var n, r = 0; for (n in t ) r = (r << 5) -r + t.charCodeAt (n), r | = 0; return e.colors [Math.abs (r)% e.colors.length]} chức năng o (t) {chức năng n () {if (n.enables) {var t = n, r = + Ngày mới, i = r- (o | | r); t.diff = i, t.prev = o, t.curr = r , o = r; for (var s = new Array (argument.length), a = 0; a <s.length; a ++) s [a] = argument [a]; s [0] = e.coerce (s [0]), "chuỗi"! = Typeof s [0] && s.unshift ("% O "); var c = 0; s [0] = s [0] .replace (/% ([a-zA-Z%]) / g, hàm (n, r) {if (" %% " === n) return n; c ++; var o = e.formatters [r]; if ("function" == typeof o) {var i = s [c]; n = o.call (t, i), s.splice (c, 1), c -} return n}), e.formatArgs.call (t, s); var u = n.log || e.log || console.log.bind (console) ; u.apply (t, s)}} var o; return n.namespace = t, n.enables = e.enables (t), n.useColors = e.useColors (), n.color = r (t) , n.destroy = i, "function" == typeof e.init && e.init (n), e.instances.push (n), n} chức năng i () {var t = e.instances.indexOf (this); return t! == - 1 && (e.instances.splice (t, 1),! 0)} hàm s (t) {e.save (t), e.names = [], e.skips = []; var n, r = ("chuỗi" == typeof t? t: ""). split (/ [\ s,] + /), o = r.length; for (n = 0; n <o; n ++) r [n] && (t = r [n] .replace (/ \ * / g, ". *?"), "-" === t [0]? e.skips.push (RegExp mới ("^ "+ t.substr (1) +" $ ")): e.tên.push (RegExp mới ("^" + t + "$"))); for (n = 0; n <e.instances.length; n ++) {var i = e.instances [n]; i.enatted = e.enables (i.namespace)}} chức năng a () {e.enable ("")} chức năng c (t) {if ("*" === t [t.length-1]) return! 0; var n, r; for (n = 0, r = e.skips.length; n <r; n ++) if (e.skips [n] .test (t)) return! 1; for (n = 0, r = e.names.length; n <r; n ++) if (e.names [n] .test (t)) return! 0; return! 1} hàm u (t) {return t instanceof Error? t.stack | | t.message: t} e = t.exports = o.debug = o ["default"] = o, e.coerce = u, e.disable = a, e.enable = s, e.enables = c, e.humanize = n (6), e.instances = [], e.names = [], e.skips = [], e.formatters = {}}, hàm (t, e) {function n (t) {if (t = String (t) ,! (t.length> 100)) {var e = / ^ ((?: \ d +)? \.? \ d +) * (mili giây? | msecs? | ms | giây ? | giây? | s | phút? | phút? | m | giờ? | giờ? | h | ngày? | d | năm? | yrs? | y)? $ / i.exec (t); if (e) {var n = parseFloat (e [1]), r = (e [2] || "ms "). toLowerCase (); switch (r) {case" năm ": case" năm ": case" yrs ": case" yr ": case" y ": return n * p; case" days ": case" day ": case" d ": return n * u; case" hours ": case" hours ": case" hours ": case" hr ": case" h ": return n * c; case" phút ": case" phút ": trường hợp" phút ": trường hợp" tối thiểu ": trường hợp" m ": return n * a; trường hợp" giây ": trường hợp" giây ": trường hợp" giây ": trường hợp" giây ": trường hợp" s ": return n * s; case "milliseconds": case "millisecond": case "msecs": case "msec": case "ms": return n; default: return}}}} chức năng r (t) {return t> = u? Math.round (t / u) + "d": t> = c? Math.round (t / c) + "h": t> = a? Math.round (t / a) + "m": t > = s? Toán.vòng (t / s) + "s": t + "ms"} hàm o (t) {return i (t, u, "day") || i (t, c, "giờ") || i (t , a, "phút") || i (t, s, "giây") || t + "ms"} hàm i (t, e, n) {if (! (t <e)) return t <1.5 * e? Math.floor (t / e) + "" + n: Math.ceil (t / e) + "" + n + "s"} var s = 1e3, a = 60 * s, c = 60 * a, u = 24 * c, p = 365.25 * u; t.exports = function (t, e) {e = e | | {}; var i = typeof t; if ("chuỗi" === i && t.length> 0 ) return n (t); if ("number" === i && isNaN (t) ===! 1) return e ["long"]? o (t): r (t); ném Lỗi mới ("val là không phải là một chuỗi không trống hoặc một số hợp lệ. val = "+ JSON.opesify (t))}}, function (t, e, n) {function r () {} function o (t) {var n =" "+ t.type; if (e.BINARY_EVENT! == t.type && e.BINARY_ACK! == t.type || (n + = t.attachments +" - "), t.nsp &&" / "! == t.nsp(n + = t.nsp + ","), null! = t.id && (n + = t.id), null! = t.data) {var r = i (t.data); if (r ===! 1) return g; n + = r} return f ("được mã hóa% j dưới dạng% s", t, n), n} hàm i (t) {thử {return JSON.opesify (t)} Catch (e) {return ! 1}} hàm s (t, e) {function n (t) {var n = d.deconstructPacket (t), r = o (n.pquet), i = n.buffers; i.unshift (r), e (i)} d.removeBlobs (t, n)} chức năng a () {this.reconstructor = null} chức năng c (t) {var n = 0, r = {type: Number (t.charAt (0)) }; if (null == e.types [r.type]) return h ("loại gói không xác định" + r.type); if (e.BINARY_EVENT === r.type || e.BINARY_ACK === r .type) {for (var o = ""; "-"! == t.charAt (++ n) && (o + = t.charAt (n), n! = t.length);); if (o ! = Số (o) || "-"! == t.charAt (n)) ném Lỗi mới ("tệp đính kèm bất hợp pháp"); r.attachments = Số (o)} if ("/" === t. charAt (n + 1)) cho (r.nsp = ""; ++ n;) {var i = t.charAt (n); if (","=== i) break; if (r.nsp + = i, n === t.length) break} other r.nsp = "/"; var s = t.charAt (n + 1); if ("" ! == s && Số (s) == s) {for (r.id = ""; ++ n;) {var i = t.charAt (n); if (null == i | | Số (i)! = i) {- n; break} if (r.id + = t.charAt (n), n === t.length) break} r.id = Number (r.id)} if (t.charAt ( ++ n)) {var a = u (t.substr (n)), c = a! ==! 1 && (r.type === e.ERROR || y (a)); if (! c) return h ("payload không hợp lệ"); r.data = a} return f ("đã giải mã% s là% j", t, r), r} hàm u (t) {thử {return JSON.parse (t)} hàm Catch (e) {return! 1}} p (t) {this.reconPack = t, this.buffers = []} chức năng h (t) {return {type: e.ERROR, data: "lỗi trình phân tích cú pháp:" + t}} var f = n (3) ("socket.io-Parser"), l = n (8), d = n (9), y = n (10), m = n (11); e .protatio = 4, e.types = ["CONNECT", "DISCONNECT", "EVENT", "ACK", "ERROR", "BINARY_EVENT", "BINARY_ACK"], e.CONNECT = 0, e.DISCONNECT = 1, e.EVENT = 2, e.ACK = 3, e.ERROR = 4, e.BINARY_EVENT = 5, e.BINARY_ACK = 6, e.Encoder = r, e.Decoder = a; var g = e.ERROR + '"lỗi mã hóa"'; r.prototype.encode = function (t, n) {if (f ("gói mã hóa% j", t), e.BINARY_EVENT = == t.type || e.BINARY_ACK === t.type) s (t, n); other {var r = o (t); n ([r])}}, l (a.prototype), a.prototype.add = function (t) {var n; if ("chuỗi" == typeof t) n = c (t), e.BINARY_EVENT === n.type || e.BINARY_ACK === n. loại? (this.reconstructor = new p (n), 0 === this.reconstructor.reconPack.attachments && this.emit ("decoding", n)): this.emit ("decoding", n); other {if ( ! m (t) &&! t.base64) ném Lỗi mới ("Loại không xác định:" + t); if (! this.reconstructor) ném Lỗi mới ("nhận dữ liệu nhị phân khi không xây dựng lại gói"); n = này .reconstructor.takeBinaryData (t), n && (this.reconstructor = null, cái này.emit ("đã giải mã", n))}}, a.prototype.destroy = function () {this.reconstructor && this.reconstructor.finishedReconemony ()}, p.prototype.takeBinaryData = function (t) {if (this đẩy (t), this.buffers.length === this.reconPack.attachments) {var e = d.reconstructPacket (this.reconPack, this.buffers); return this.finishedReconemony (), e} return null}, p .prototype.finishedRecon cản = function () {this.reconPack = null, this.buffers = []}}, function (t, e, n) {function r (t) {if (t) return o (t)} o (t) {for (var e in r.prototype) t [e] = r.prototype [e]; return t} t.exports = r, r.prototype.on = r.prototype.addEventListener = function (t , e) {return this._callbacks = this._callbacks || {}, (this._callbacks ["$" + t] = this._callbacks ["$" + t] || []). push (e), this}, r.prototype.once = function (t, e) {function n () {this.off (t, n), e.apply (this, argument)} return n.fn = e, this.on ( t,n), this}, r.prototype.off = r.prototype.removeListener = r.prototype.removeAllListener = r.prototype.removeEventListener = function (t, e) {if (this._callbacks = this._callbacks , 0 == argument.length) return this._callbacks = {}, this; var n = this._callbacks ["$" + t]; if (! N) trả lại cái này; if (1 == argument.length) return xóa cái này._callbacks ["$" + t], cái này; for (var r, o = 0; o <n.length; o ++) if (r = n [o], r === e | | r.fn === e) {n.splice (o, 1); break} trả lại cái này}, r.prototype.emit = function (t) {this._callbacks = this._callbacks || {}; var e = []. lát.call (đối số, 1), n ​​= this._callbacks ["$" + t]; if (n) {n = n.slice (0); for (var r = 0, o = n.length; r <o; ++ r) n [r] .apply (this, e)} trả lại cái này}, r.prototype.listpers = function (t) {return this._callbacks = this._callbacks || {}, this._callbacks ["$" + t] | |e, n) {(function (t) {function r (t, e) {if (! t) return t; if (s (t)) {var n = {_ giữ chỗ :! 0, num: e.length} ; return e.push (t), n} if (i (t)) {for (var o = new Array (t.length), a = 0; a <t.length; a ++) o [a] = r (t [a], e); return o} if ("object" == typeof t &&! (t instanceof Date)) {var o = {}; for (var c in t) o [c] = r (t [c], e); return o} return t} function o (t, e) {if (! t) return t; if (t && t._placeholder) return e [t.num]; if (i (t)) for (var n = 0; n <t.length; n ++) t [n] = o (t [n], e); other if ("object" == typeof t) for (var r in t) t [t r] = o (t [r], e); return t} var i = n (10), s = n (11), a = Object.prototype.toString, c = "function" == typeof t.Blob || "[object BlobConstructor]" === a.call (t.Blob), u = "function" == typeof t.File || "[object FileConstructor]" === a.call (t.File) ; e.deconstructPacket = function (t) {var e = [], n = t.data, o = t; return o.data = r (n, e), o.attachments = e.length,{gói: o, bộ đệm: e}}, e.reconstructPacket = function (t, e) {return t.data = o (t.data, e), t.attachments = void 0, t}, e.removeBlobs = function (t, e) {function n (t, a, p) {if (! t) return t; if (c && t instanceof Blob | | u && t instanceof File) {r ++; var h = new FileReader; h.onload = function () {p? p [a] = this.result: o = this.result, - r || e (o)}, h.readAsArrayBuffer (t)} khác if (i (t)) cho (var f = 0; f <t.length; f ++) n (t [f], f, t); other if ("object" == typeof t &&! S (t)) cho (var l in t) n (t [ l], l, t)} var r = 0, o = t; n (o), r || e (o)}}). gọi (e, function () {return this} ())}, hàm (t, e) {var n = {}. toString; t.exports = Array.isArray || function (t) {return "[Array Array]" == n.call (t)}}, function (t, e) {(function (e) {function n (t) {return r && e.Buffer.isBuffer (t) || o && (t instanceof e.ArrayBuffer || i (t))} t.exports = n; var r = "hàm" == typeof e.Buffer && "function "== typeof e.Buffer.isBuffer, o =" function "== typeof e.ArrayBuffer, i = function () {return o &&" function "== typeof e.ArrayBuffer.isView? e.ArrayBuffer.isView: (t) {return t.buffer instanceof e.ArrayBuffer}} ()}). call (e, function () {return this} ())}, function (t, e, n) {"userict"; function r (t, e) {if (! (ví dụ này r)) trả về r (t, e); t && "object" === ("không xác định" == typeof t? "không xác định": o (t)) && (e = t, t = void 0), e = e || {}, e.path = e.path || "/socket.io", this.nsps = {}, this.sub = [], this.opts = e, this.recconnectection (e.reconnection! ==! 1), this.reconnectionAttvor (e.reconnectionAttvor || 1/0), this.reconnectionDelay (e.reconnectionDelay || 1e3), this e.reconnectionDelayMax || 5e3), this.randomizationFactor (e.randomizationFactor || .5), this.backoff = new l ({min: this.reconnectionDelay (), max: this.reconnectionDelayMax (), jitter: this.randomizationFactor ()}), this.timeout (null == e.timeout? 2e4: e.timeout), this. yetState = "shut", this. uri = t, this.connecting = [], this.lastPing = null, this.encoding =! 1, this.pquetBuffer = []; var n = e.parser || c; this.encoder = new n.Encoder, this.decoder = new n.Decoder, this.autoConnect = e.autoConnect! ==! 1, this.autoConnect && this.open ()} var o = "function" == typeof Symbol && "Symbol" == typeof Symbol.iterator? function (t) {return typeof t}: function (t) {return t && "function" == typeof Symbol && t.constructor === Symbol && t! == Symbol.prototype? "Symbol": typeof t}, i = n (13 ), s = n (37), a = n (8), c = n (7), u = n (39), p = n (40), h = n (3) ("socket.io-client : người quản lý "), f = n (36), l = n (41), d = Object.prototype.hasOwnProperty; t.exports = r, r.prototype.emitAll = function () {this.emit.apply (this, argument); for (var t in this.nsps) d.call (this.nsps, t) && this.nsps [t] .emit.apply (this.nsps [t], đối số)}, r.prototype.updateSocketIds = function () {for (var t in this.nsps) d.call (this.nsps, t) && (this.nsps [t] .id = this. GenerId (t))}, r.prototype.generateId = function (t) {return ("/" === t? "": t + "#") + this.engine.id}, a (r.prototype) , r.prototype.reconnection = function (t) {return argument.length? (this._reconnection = !! t, this): this._reconnection}, r.prototype.reconnectionAttvor = function (t) {return argument.length? (this._reconnectionAttvor = t, this): this._reconnectionAttvor}, r.prototype.reconnectionDelay = function (t) {return argument.length? (this._reconnectionDelay = t, this.backoff && this. ): this._reconnectionDelay}, r.prototype.RandomizationFactor = function (t) {return argument.length? (this._randomizationFactor = t, this.backoff && this.backoff.setJitter (t), this): this._randomizationFactor}, r.prototype.reconnectionDelayMax argument.length? (this._reconnectionDelayMax = t, this.backoff && this.backoff.setMax (t), this): this._reconnectionDelayMax}, r.prototype.timeout = function (t) {return argument.le = t, this): this._timeout}, r.prototype.maybeReconnectOnOpen = function () {! this.reconnecting && this._reconnection && 0 === this.backoff.attvor && this.reconnect ()}, r.prot .connect = function (t, e) {if (h ("readyState% s", this. yetState), ~ this. yetState.indexOf ("open")) trả lại cái này; h ("open% s", cái này. uri), this.engine = i (this.uri, this.opts); var n = this.engine, r = this; this.readyState = "Opening", this.skipReconnect =! 1; var o = u (n, "open", function () {r.onopen (), t && t ()}), s = u (n, "error", function (e) {if (h ("connect_error"), r.cleanup (), r. yetState = "shut", r.emit ALL ("connect_error", e), t) {var n = new Error ("Connection lỗi "); n.data = e, t (n)} khác r.maybeReconnectOnOpen ()}); if (! 1! == this._timeout) {var a = this._timeout; h (" kết nối sẽ hết thời gian chờ sau% d ", a); var c = setTimeout (function () {h (" kết nối đã hết thời gian sau% d ", a), o.destroy (), n.close (), n.emit (" error "," hết thời gian "), r.emit ALL (" connect_timeout ", a)}, a); this.sub.push ({hủy: function () {clearTimeout (c)}})} return this.sub.push ( o), this.sub.push (s), this}, r.prototype.onopen = function () {h ("open"), this.cleanup (), this. yetState = "open",this.emit ("open"); var t = this.engine; this.sub.push (u (t, "data", p (this, "ondata"))), this.sub.push (u (t , "ping", p (this, "onping"))), this.sub.push (u (t, "pong", p (this, "onpong"))), this.sub.push (u (t , "lỗi", p (this, "onerror"))), this.sub.push (u (t, "close", p (this, "onclose"))), this.sub.push (u (this .decoder, "đã giải mã", p (this, "ondecoding")))}, r.prototype.onping = function () {this.lastPing = new Date, this.emit ALL ("ping")}, r.prototype. onpong = function () {this.emit ALL ("pong", new Date-this.lastPing)}, r.prototype.ondata = function (t) {this.decoder.add (t)}, r.prototype.ondecoding = hàm (t) {this.emit ("gói", t)}, r.prototype.onerror = function (t) {h ("error", t), this.emit ALL ("error", t)}, r .prototype.socket = function (t, e) {function n () {~ f (o.connecting, r) || o.connecting.push (r)} var r = this.nsps [t]; if (! r) { r = new s (this, t, e), this.nsps [t] = r; var o = this; r.on ("kết nối", n), r.on ("kết nối", function () {r .id = o.generateId (t)}), this.autoConnect && n ()} return r}, r.prototype.destroy = function (t) {var e = f (this.connecting, t); ~ e && this.connecting. splice (e, 1), this.connecting.length || this.close ()}, r.prototype.pquet = function (t) {h ("viết gói% j", t); var e = this; t .query && 0 === t.type && (t.nsp + = "?" + t.query), e.encoding? e.pquetBuffer.push (t) :( e.encoding =! 0, this.encoder.encode (t , function (n) {for (var r = 0; r <n.length; r ++) e.engine.write (n [r], t.options); e.encoding =! 1, e. processPquetQueue ()} ))}, r.prototype. ProcessPquetQueue = function () {if (this.pquetBuffer.length> 0 &&! this.encoding) {var t = this.packBuffer.shift (); this.pquet (t)}}, r.prototype.cleanup = function () {h ("dọn dẹp"); for (var t = this.sub.length, e = 0; e <t ; e ++) {var n = this.sub.shift (); n.destroy ()} this.pquetBuffer = [], this.encoding =! 1, this.lastPing = null, this.decoder.destroy ()}, r.prototype.close = r.prototype.disconnect = function () {h ("disconnect"), this.skipReconnect =! 0, this.reconnecting =! 1, "Opening" === this. yetState && this.cleanup () , this.backoff.reset (), this. yetState = "shut", this.engine && this.engine.close ()}, r.prototype.onclose = function (t) {h ("onclose"), this.cleanup ( ), this.backoff.reset (), this. yetState = "shut", this.emit ("close", t), this._reconnection &&! this.skipReconnect && this.reconnect ()}, r.prototype.reconnect = ) {if (this.recconnectecting | | this.skipReconnect) trả lại cái này;var t = this; if (this.backoff.attvor> = this._reconnectionAttvor) h ("kết nối lại thất bại"), this.backoff.reset (), this.emit ALL ("reconnect_fails"), this.reconnecting =! 1; } {var e = this.backoff.duration (); h ("sẽ đợi% dms trước khi kết nối lại lần thử", e), this.recconnectecting =! 0; var n = setTimeout (function () {t.skipReconnect || ( h ("cố gắng kết nối lại"), t.emit ALL ("recconnectect_atteem", t.backoff.attvor), t.emit ALL ("kết nối lại", t.backoff.attvor), t.skipReconnect (| t.open (hàm) ) {e? (h ("lỗi kết nối lại"), t.reconnecting =! 1, t.reconnect (), t.emit ALL ("reconnect_error", e.data)) :( h ("kết nối lại thành công"), t.onreconnect ())}))}, e); this.sub.push ({hủy: function () {clearTimeout (n)}})}}, r.prototype.onreconnect = function () {var t = this .backoff.attvor; this.recconnectecting =! 1, cái này.backoff.reset (), this.updateSocketIds (), this.emit ALL ("recconnectect", t)}}, function (t, e, n) {t.exports = n (14), t.exports.parser = n (21)}, hàm (t, e, n) {(function (e) {function r (t, n) {if (! (Ví dụ này r)) trả về r (t, n); n = n | | {}, t && "object" == typeof t && (n = t, t = null), t? (t = p (t), n.hostname = t.host, n.secure = "https" === t.protatio || "wss" === t.protatio, n.port = t.port, t.query && (n.query = t.query)): n.host && (n.hostname = p (n.host ) .host), this.secure = null! = n.secure? n.secure: e.location && "https:" === location.protatio, n.hostname &&! n.port && (n.port = this.secure? "443": "80"), this.agent = n.agent ||! 1, this.hostname = n.hostname || (e.location? Location.hostname: "localhost"), this.port = n. cổng || (e.location && location.port? location.port: this.secure? 443: 80),this.query = n.query || {}, "string" == typeof this.query && (this.query = h.decode (this.query)), this.upTHER =! 1! == n.upup, this .path = (n.path || "/engine.io"). thay thế (/ \ / $ /, "") + "/", this.forceJSONP = !! n.forceJSONP, this.jsonp =! 1! == n.jsonp, this.forceBase64 = !! n.forceBase64, this.enablesXDR = !! n.enablesXDR, this.timestampParam = n.timestampParam || "t", this.timestampRequests = n.timestamp = n.transports || ["bỏ phiếu", "websocket"], this.transportOptions = n.transportOptions || {}, this. yetState = "", this.writeBuffer = [], this.prevBufferLen = 0. chính sáchPort = n.policyPort || 843, this.rememberUpgrad = n.rememberUpgrad ||! 1, this.binaryType = null, this.onlyBinaryUpgrades = n.onlyBinaryUpgrades, this.perMessageDeflate =! 1 = perMessageDeflate || {}) ,! 0 === này.perMessageDeflate && (this.perMessageDeflate = {}), this.perMessageDeflate && null == this.perMessageDeflate.thrftime && (this.perMessageDeflate.thrftime = 1024), this.pfx = n.p. null, this.passphrase = n.passphrase || null, this.cert = n.cert || null, this.ca = n.ca | | null, this.ciphers = n.ciphers || null, this.rejectUnauthorized = void 0 === n.rejectUnauthorized || n.rejectUnauthorized, this.forceNode = !! n.forceNode; var o = "object" == typeof e && e; o.global === o && (n.extraHeaders && .extraHeaders) .length> 0 && (this.extraHeaders = n.extraHeaders), n.localAddress && (this.localAddress = n.localAddress)), this.id = null, this.upgrades = null, this .pingTimeout = null, this.pingIntervalTimer = null, this.pingTimeoutTimer = null, this.open ()} chức năng o (t) {var e = {}; for (var n in t) t.hasOwnProperty (n) && (e [n] = t [n]); return e} var i = n (15), s = n (8), a = n (3) ("engine.io-client: socket "), c = n (36), u = n (21), p = n (2), h = n (30); t.exports = r, r.p WarriorWebsocketSuccess =! 1, s (r.prototype) , r.protatio = u.protatio, r.Socket = r, r.Transport = n (20), r.transports = n (15), r.parser = n (21), r.prototype.createTransport = function ( t) {a ('tạo vận chuyển "% s"', t); var e = o (this.query); e.EIO = u.protatio, e.transport = t; var n = this.transportOptions [t] || {}; this.id && (e.sid = this.id); var r = new i [t] ({query: e, socket: this, agent: n.agent || this.agent, hostname: n .hostname || this.hostname, port: n.port || this.port, safe: n.secure || this.secure, path: n.path || this.path, forceJSONP: n.forceJSONP || này. forceJSONP, jsonp: n.jsonp || this.jsonp, forceBase64: n.forceBase64 || this.forceBase64, enableXDR: n.enablesXDR || this.enablesXDR, timestampRequests: n.timestampRequests |timestampRequests, timestampParam: n.timestampParam || this.timestampParam, chính sáchPort: n.policyPort || this.policyPort, pfx: n.pfx || this.pfx, key: n.key || this.key, pass cụm mật khẩu | | this.passphrase, cert: n.cert | | this.cert, ca: n.ca || this.ca, mật mã: n.ciphers || this.ciphers, từ chốiUnauthorized: n.rejectUnauthorized || this.rejectUna , perMessageDeflate: n.perMessageDeflate || this.perMessageDeflate, ExtraHeaders: n.extraHeaders || this.extraHeaders, forceNode: n.forceNode || this.forceNode, localAddress: n. || this.requestTimeout, các giao thức: n.prot Protocol || void 0}); return r}, r.prototype.open = function () {var t; if (this.rememberUpTHER && r.p WarriorWebsocketSuccess && this.transports.ind " )! == - 1) t = "websocket"; other {if (0 === this.transports.length) {var e = this;return void setTimeout (function () {e.emit ("error", "Không có vận chuyển khả dụng")}, 0)} t = this.transports [0]} this. yetState = "opens"; thử {t = this. createdTransport (t)} Catch (n) {return this.transports.shift (), void this.open ()} t.open (), this.setTransport (t)}, r.prototype.setTransport = function (t) {a ("thiết lập vận chuyển% s", t.name); var e = this; this.transport && (a ("xóa giao thông hiện tại% s", this.transport.name), this.transport.removeAllListener ()) this .transport = t, t.on ("Drain", function () {e.onDrain ()}). on ("pack", function (t) {e.onPacket (t)}). on ("error ", function (t) {e.onError (t)}). on (" close ", function () {e.onClose (" Transport close ")})}, r.prototype.probe = function (t) { hàm e () {if (f.onlyBinaryUpgrades) {var e =! this.supportsBinary && f.transport.hỗ trợBinary; h = h || e} h || (a ('vận chuyển thăm dò "% s" đã mở', t), p.send ([{type: "ping", dữ liệu: "thăm dò"}]), p .once ("gói", hàm (e) {if (! h) if ("pong" === e.type && "thăm dò" === e.data) {if (a ('đầu dò vận chuyển "% s" pong ', t), f.upgrad =! 0, f.emit ("nâng cấp", p) ,! p) return; r.p WarriorWebsocketSuccess = "websocket" === p.name, a (' tạm dừng vận chuyển hiện tại " % s "', f.transport.name), f.transport.pause (function () {h ||" shut "! == f. yetState && (a (" thay đổi vận chuyển và gửi gói nâng cấp "), u () , f.setTransport (p), p.send ([{type: "nâng cấp"}]), f.emit ("nâng cấp", p), p = null, f.upgrad =! 1, f.flush () )})} other {a ('thăm dò vận chuyển "% s" không thành công', t); var n = new Error ("lỗi thăm dò"); n.transport = p.tên, f.emit ("nâng cấpError", n)}}))} hàm n () {h || (h =! 0, u (), p.close (), p = null)} hàm o (e ) {var r = new Error ("lỗi thăm dò:" + e); r.transport = p.name, n (), a ('đầu dò vận chuyển "% s" không thành công do lỗi:% s', t, e ), f.emit ("nâng cấpError", r)} = p.name && (a ('"% s" hoạt động - hủy bỏ "% s"', t.name, p.name), n ())} chức năng u () {p.removeListener ("open", e) , p.removeListener ("error", o), p.removeListener ("close", i), f.removeListener ("close", s), f.removeListener ("nâng cấp", c)} a ('thăm dò vận chuyển "% s" ', t); var p = this.createTransport (t, {thăm dò: 1}), h =! 1, f = this; r.p WarriorWebsocketSuccess =! 1, p.once ("mở", e ), p.một lần ("lỗi", o), p.once ("đóng", i), this.once ("đóng", s), this.once ("nâng cấp", c), p.open ()}, r .prototype.onOpen = function () {if (a ("socket open"), this. yetState = "open", r.p WarriorWebsocketSuccess = "websocket" === this.transport.name, this.emit ("open" ), this.flush (), "open" === this. yetState && this.upTHER && this.transport.pause) {a ("bắt đầu nâng cấp thăm dò"); for (var t = 0, e = this.upgrades.length; t <e; t ++) this.probe (this.upgrades [t])}}, r.prototype.onPacket = function (t) {if ("open" === this. yetState || "open" === this . yetState || "đóng" === this. yetState) (a ('socket receive: gõ "% s", dữ liệu "% s"', t.type, t.data), this.emit ("gói ", t), this.emit (" nhịp tim "), t.type) {case"mở ": this.onHandshake (JSON.parse (t.data)); break; case" pong ": this.setPing (), this.emit (" pong "); break; case" error ": var e = new Lỗi ("lỗi máy chủ"); e.code = t.data, this.onError (e); break; case "message": this.emit ("data", t.data), this.emit ("message" , t.data)} khác a ('gói nhận được với socket readyState "% s"', this. yetState)}, r.prototype.onHandshake = function (t) {this.emit ("handshake", t), this .id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades (t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this. onOpen (), "đã đóng"! == this. yetState && (this.setPing (), this.removeListener ("heartbeat", this.onHeartbeat), this.on ("heartbeat", this.onHeartbeat)), r. nguyên mẫu.onHeartbeat = function (t) {clearTimeout (this.pingTimeoutTimer); var e = this; e.pingTimeoutTimer = setTimeout (function () {"shut"! == e. yetState && e.onClose ("ping timeout")}, t | e.pingInterval + e.pingTimeout)}, r.prototype.setPing = function () {var t = this; clearTimeout (t.pingIntervalTimer), t.pingIntervalTimer = setTimeout (function () {a ("viết gói ping - mong đợi pong trong% sms ", t.pingTimeout), t.ping (), t.onHeartbeat (t.pingTimeout)}, t.pingInterval)}, r.prototype.ping = function () {var t = this; .sendPacket ("ping", function () {t.emit ("ping")})}, r.prototype.onDrain = function () {this.writeBuffer.splice (0, this.prevBufferLen), this.prevBufferLen = 0,0 === this.writeBuffer.length? This.emit ("Drain"): this.flush ()}, r.prototype.flush = function () {"shut"! == this. YetState && this.transport.writable &&! this.up Nâng cấp && this.writeBuffer.length && (a ("tuôn ra% d gói trong socket", this.writeBuffer.length), this.transport.send (this.writeBuffer), this.prevBufferLen .emit ("flush"))}, r.prototype.write = r.prototype.send = function (t, e, n) {return this.sendPacket ("message", t, e, n), this}, r.prototype.sendPacket = function (t, e, n, r) {if ("function" == typeof e && (r = e, e = void 0), "function" == typeof n && (r = n, n = null), "đóng"! == this. yetState && "shut"! == this. yetState) {n = n || {}, n.compress =! 1! == n.compress; var o = {type : t, dữ liệu: e, tùy chọn: n}; this.emit ("packCreate", o), this.writeBuffer.push (o), r && this.once ("flush", r), this.flush ()}} , r.prototype.close = function () {function t () {r.onClose ("buộc đóng "), một (" đóng ổ cắm - nói vận chuyển để đóng "), r.transport.close ()} chức năng e () {r.removeListener (" nâng cấp ", e), r.removeListener (" nâng cấpError ", e), t ()} chức năng n () {r.once ("nâng cấp", e), r.once ("nâng cấpError", e)} if ("open" === this. yetState || "open" === this. yetState) {this. yetState = "clos"; var r = this; this.writeBuffer.length? This.once ("Drain", function () {this.up nâng cấp? N (): t () }): this.upgrad? n (): t ()} return this}, r.prototype.onError = function (t) {a ("lỗi socket% j", t), r.p WarriorWebsocketSuccess =! 1, cái này .emit ("lỗi", t), this.onClose ("lỗi vận chuyển", t)}, r.prototype.onClose = function (t, e) {if ("mở" === this. yetState || " mở "=== this. yetState ||" đóng "=== this. yetState) {a ('socket gần với lý do: "% s" ', t); var n = this; clearTimeout (this.pingIntervalTimer), clearTimeout (this.pingTimeoutTimer), this.transport.removeAllListener ("close"), this.transport.close ( ), this.transport.remove ALLListener (), this. yetState = "shut", this.id = null, this.emit ("close", t, e), n.writeBuffer = [], n.prevBufferLen = 0} }, r.prototype.filterUpgrades = function (t) {for (var e = [], n = 0, r = t.length; n <r; n ++) ~ c (this.transports, t [n]) && e .push (t [n]); return e}}). call (e, function () {return this} ())}, function (t, e, n) {(function (t) {function r (e ) {var n, r =! 1, a =! 1, c =! 1! == e.jsonp; if (t.location) {var u = "https:" === location.protatio, p = location .Hải cảng;đóng "), this.transport.close (), this.transport.remove ALLListener (), this. yetState =" shut ", this.id = null, this.emit (" close ", t, e), n.writeBuffer = [], n.prevBufferLen = 0}}, r.prototype.filterUpgrades = function (t) {for (var e = [], n = 0, r = t.length; n <r; n ++) ~ c ( this .transports, t [n]) && e.push (t [n]); return e}}). call (e, function () {return this} ())}, function (t, e, n) { (hàm (t) {function r (e) {var n, r =! 1, a =! 1, c =! 1! == e.jsonp; if (t.location) {var u = "https:" === location.protatio, p = location.port;đóng "), this.transport.close (), this.transport.remove ALLListener (), this. yetState =" shut ", this.id = null, this.emit (" close ", t, e), n.writeBuffer = [], n.prevBufferLen = 0}}, r.prototype.filterUpgrades = function (t) {for (var e = [], n = 0, r = t.length; n <r; n ++) ~ c ( this .transports, t [n]) && e.push (t [n]); return e}}). call (e, function () {return this} ())}, function (t, e, n) { (hàm (t) {function r (e) {var n, r =! 1, a =! 1, c =! 1! == e.jsonp; if (t.location) {var u = "https:" === location.protatio, p = location.port;hàm () {return this} ())}, function (t, e, n) {(function (t) {function r (e) {var n, r =! 1, a =! 1, c =! 1 ! == e.jsonp; if (t.location) {var u = "https:" === location.protatio, p = location.port;hàm () {return this} ())}, function (t, e, n) {(function (t) {function r (e) {var n, r =! 1, a =! 1, c =! 1 ! == e.jsonp; if (t.location) {var u = "https:" === location.protatio, p = location.port;
p || (p = u? 443: 80), r = e.hostname! == location.hostname || p! == e.port, a = e.secure! == u} if (e.xdomain = r, e.xscheme = a, n = new o (e), "open" trong n &&! e.forceJSONP) trả về i mới (e); if (! c) ném Lỗi mới ("JSONP bị vô hiệu hóa"); s (e)} var o = n (16), i = n (18), s = n (33), a = n (34); e.polling = r, e.websocket = a}). call ( e, function () {return this} ())}, function (t, e, n) {(function (e) {var r = n (17); t.exports = function (t) {var n = t .xdomain, o = t.xscheme, i = t.enablesXDR; thử {if ("không xác định"! = typeof XMLHttpRequest && (! n || r)) trả về XMLHttpRequest} mới bắt (s) {} thử {if ("không xác định "! = typeof XDomainRequest &&! o && i) trả lại XDomainRequest} mới bắt (s) {} if (! n) thử {return new (e [[" Active "]. concat (" Object "). tham gia (" X ")] ) ("Microsoft.XMLHTTP")} Catch (s) {}}}). Call (e, function () {return this} ())}, function (t, e) {thử {t.export = "không xác định"! = typeof XMLHttpRequest && "withCredentials" trong XMLHttpRequest} Catch (n) {t.exports =! 1}}, function (t, e, n) {(function (e) {function r () { } hàm o (t) {if (c.call (this, t), this.requestTimeout = t.requestTimeout, this.extraHeaders = t.extraHeaders, e.location) {var n = "https:" === location .protatio, r = location.port; r || (r = n? 443: 80), this.xd = t.hostname! == e.location.hostname || r! == t.port, this.xs = t.secure! == n}} chức năng i (t) {this.method = t.method || "GET", this.uri = t.uri, this.xd = !! t.xd, this.xs = !! t.xs, this.async =! 1! == t.async, this.data = void 0! == t.data?t.data:null,this.agent=t.agent,this.isBinary = t.isBinary, this.supportsBinary = t.supportsBinary, this.enablesXDR = t.enablesXDR, this.requestTimeout = t.requestTimeout, this.pfx = t.pfx, this.key = t.key, this.passph = .passphrase, this.cert = t.cert, this.ca = t.ca, this.ciphers = t.mật mã, this.rejectUnauthorized = t.rejectUnauthorized, this.extraHeaders = t.extraHeaders, this.create ()} function s () {for (var t in i.requests) i.requests.hasOw t] .abort ()} var a = n (16), c = n (19), u = n (8), p = n (31), h = n (3) ("engine.io-client: polling-xhr "); t.exports = o, t.exports.Request = i, p (o, c), o.prototype.supportsBinary =! 0, o.prototype.request = function (t) {return t = t || {}, t.uri = this.uri (), t.xd = this.xd, t.xs = this.xs, t.agent = this.agent ||! 1, t.supportsBinary = this. hỗ trợBinary, t.enablesXDR = this.enablesXDR, t.pfx = this.pfx, t.key = this.key, t.passphrase = this.passphrase, t.cert = this.cert, t.ca = this.ca, t.ciphers = this.ciphers, t.rejectUnauthorized = this.rejectUnauthorized, t.requestTimeout = this.requestTimeout, t.extraHeaders = this.extraHeaders, new i (t)}, o.prot = ) {var n = "chuỗi"! = typeof t && void 0! == t,r = this.request ({phương thức: "POST", dữ liệu: t, isBinary: n}), o = this; r.on ("thành công", e), r.on ("lỗi", hàm (t) {o.onError ("lỗi bài xhr", t)}), this.sendXhr = r}, o.prototype.doPoll = function () {h ("xhr poll"); var t = this.request (), e = this; t.on ("data", function (t) {e.onData (t)}), t.on ("error", function (t) {e.onError ("xhr poll error", t )}), this.pollXhr = t}, u (i.prototype), i.prototype.create = function () {var t = {agent: this.agent, xdomain: this.xd, xscheme: this.xs, enableXDR: this.enablesXDR}; t.pfx = this.pfx, t.key = this.key, t.passphrase = this.passphrase, t.cert = this.cert, t.ca = this.ca, t.ciphers = this.ciphers, t.rejectUnauthorized = this.rejectUnauthorized; var n = this.xhr = new a (t), r = this; thử {h ("xhr open% s:% s", this.method, this. uri), n.open (this.method, this.uri, this.async); thử {if (this.extraHeaders) {n.setDisableHeaderCheck && n.setDisableHeaderCheck (! 0); for (var o in this.extraHeaders) this.extraHeaders.hasOwnProperty (o) && n.setRequestHeader (o, this.ext) "=== this.method) thử {this.isBinary? n.setRequestHeader (" Kiểu nội dung "," application / octet-stream "): n.setRequestHeader (" Kiểu nội dung "," text / plain; charset = UTF-8 ")} Catch (s) {} thử {n.setRequestHeader (" Chấp nhận "," * / * ")} Catch (s) {}" withCredentials "trong n && (n.withCredentials =! 0), điều này .requestTimeout && (n.timeout = this.requestTimeout), this.hasXDR ()? (n.onload = function () {r.onLoad ()}, n.onerror = function () {r.onError (n.response) }): n.onreadystatechange = function () {if (2 === n. yetState) thử {var t = n.getResponseHeader ("Kiểu nội dung"); r.supportsBinary && "application / octet-stream "=== t && (n.responseType =" Arraybuffer ")} Catch (e) {} 4 === n. yetState && (200 === n.status || 1223 === n.status ? r.onLoad (): setTimeout (function () {r.onError (n.status)}, 0))}, h ("xhr data% s", this.data), n.send (this.data) } Catch (s) {return void setTimeout (function () {r.onError (s)}, 0)} e.document && (this.index = i.requestsCount ++, i.requests [this.index] = this)}, i.prototype.onSuccess = function () {this.emit ("thành công"), this.cleanup ()}, i.prototype.onData = function (t) {this.emit ("data", t), this. onSuccess ()}, i.prototype.onError = function (t) {this.emit ("error", t), this.cleanup (! 0)}, i.prototype.cleanup = function (t) {if (" không xác định "! = typeof this.xhr && null! == this.xhr) {if (this.hasXDR ()? this.xhr.onload = this.xhr.onerror = r: this.xhr.onreadystatechange = r, t) thử { này.xhr.abort ()} Catch (n) {} e.document && xóa i.requests [this.index], this.xhr = null}}, i.prototype.onLoad = function () {var t; thử {var e; try { e = this.xhr.getResponseHeader ("Kiểu nội dung")} Catch (n) {} t = "application / octet-stream" === e? this.xhr.response || this.xhr.responseText: this. xhr.responseText} Catch (n) {this.onError (n)} null! = t && this.onData (t)}, i.prototype.hasXDR = function () {return "không xác định"! = typeof e.XDomainRequest &&! xs && this.enablesXDR}, i.prototype.abort = function () {this.cleanup ()}, i.requestsCount = 0, i.requests = {}, e.document && (e.attachEvent? e.attachEvent? " , s): e.addEventListener && e.addEventListener ("beforeunload", s ,! 1))}). call (e, function () {return this} ())}, function (t, e, n) {function r (t) {var e = t && t.forceBase64; p &&! e | | (this.supportsBinary =! 1), o.gọi (này, t)} var o = n (20), i = n (30), s = n (21), a = n (31), c = n (32), u = n (3) ( "engine.io-client: polling"); t.exports = r; var p = function () {var t = n (16), e = new t ({xdomain :! 1}); return null! = e .responseType} (); a (r, o), r.prototype.name = "polling", r.prototype.doOpen = function () {this.poll ()}, r.prototype.pause = function (t) {function e () {u ("đã tạm dừng"), n. yetState = "đã tạm dừng", t ()} var n = this; if (this. yetState = "pauseing", this.polling ||! this.writable) {var r = 0; this.polling && (u ("chúng tôi hiện đang bỏ phiếu - đang chờ để tạm dừng"), r ++, this.once ("pollComplete", function () {u ("hoàn thành việc bỏ phiếu trước"), - -r || e ()})), this.writable || (u ("chúng tôi hiện đang viết - đang chờ để tạm dừng"), r ++, this.once ("Drain", function () {u ("pre- tạm dừng viết hoàn thành "), - r || e ()}))} other e ()}, r.prototype.poll = function () {u ("polling"), this.polling =! 0, this.doPoll (), this.emit ("poll")}, r.prototype.onData = function (t) {var e = this; u ("polling got data% s", t); var n = function (t, n, r) {return "Opening" === e. yetState && e.onOpen (), "close" === t. loại? (e.onClose (),! 1): void e.onPacket (t)}; s.decodePayload (t, this.socket.binaryType, n), "shut"! == this. yetState && (this.polling =! 1, this.emit ("pollComplete"), "open" === this. YetState? This.poll (): u ('bỏ qua cuộc thăm dò - trạng thái vận chuyển "% s"', this. YetState)), r.prototype.doClose = function () {function t () {u ("ghi gói gần"), e.write ([{type: "close"}])} var e = this; "open" === this. yetState? (u ("vận chuyển mở - đóng"), t ()) :( u ("vận chuyển không mở - trì hoãn đóng"), cái này.một lần ("mở", t))}, r.prototype.write = function (t) {var e = this; this.writable =! 1; var n = function () {e.writable =! 0, e. emit ("cống")}; s.encodePayload (t, this.supportsBinary, function (t) {e.doWrite (t, n)})}, r.prototype.uri = function () {var t = this. truy vấn || {}, e = this.secure? "https": "http", n = "";! 1! == this.timestampRequests && (t [this.timestampParam] = c ()), this.supportsBinary | | t.sid || (t.b64 = 1), t = i.encode (t), this.port && ("https" === e && 443! == Số (this.port) || "http" == = e && 80! == Số (this.port)) && (n = ":" + this.port), t.length && (t = "?" + t); var r = this.hostname.indexOf (":" )! == - 1; return e + ": //" + (r? "[" + This.hostname + "]": this.hostname) + n + this.path + t}}, hàm (t, e, n) {hàm r (t) {this.path = t.path, this.hostname = t.tên máy chủ, this.port = t.port, this.secure = t.secure, this.query = t.query, this.timestampParam = t.timestampParam, this.timestampRequests = t.timestampRequests, this. yetState = ", .agent = t.agent ||! 1, this.socket = t.socket, this.enablesXDR = t.enablesXDR, this.pfx = t.pfx, this.key = t.key, this.passphrase = t.passphrase , this.cert = t.cert, this.ca = t.ca, this.ciphers = t.ciphers, this.rejectUnauthorized = t.rejectUnauthorized, this.forceNode = t.forceNode, this.extraHeaders = t.extraHeaders .localAddress = t.localAddress} var o = n (21), i = n (8); t.exports = r, i (r.prototype), r.prototype.onError = function (t, e) {var n = new Error (t); return n.type = "TransportError", n.descrip = e, this.emit ("error", n), this}, r.prototype.open = function () {return "đã đóng" ! == this. yetState && ""! == this. yetState || (this. yetState = "Opening", this.doOpen ()),this}, r.prototype.close = function () {return "Opening"! == this. yetState && "open"! == this. yetState || (this.doClose (), this.onClose ()), this} , r.prototype.send = function (t) {if ("open"! == this. yetState) đưa ra Lỗi mới ("Vận chuyển không mở"); this.write (t)}, r.prototype.onOpen = function () {this. yetState = "open", this.writable =! 0, this.emit ("open")}, r.prototype.onData = function (t) {var e = o.decodePacket (t, this. socket.binaryType); this.onPacket (e)}, r.prototype.onPacket = function (t) {this.emit ("pack", t)}, r.prototype.onClose = function () {this. yetState = "đã đóng", this.emit ("close")}}, function (t, e, n) {(function (t) {function r (t, n) {var r = "b" + e.packets [t .type] + t.data.data; return n (r)} hàm o (t, n, r) {if (! n) return e.encodeBase64Packet (t, r); var o = t.data, i = Uint8Array mới (o),s = new Uint8Array (1 + o.byteLpm); s [0] = v [t.type]; for (var a = 0; a <i.length; a ++) s [a + 1] = i [a] ; return r (s.buffer)} function i (t, n, r) {if (! n) return e.encodeBase64Packet (t, r); var o = new FileReader; return o.onload = function () {t .data = o.result, e.encodePacket (t, n ,! 0, r)}, o.readAsArrayBuffer (t.data)} chức năng s (t, n, r) {if (! n) trả về e.encodeBase64Packet (t, r); if (g) return i (t, n, r); var o = new Uint8Array (1); o [0] = v [t.type]; var s = new k ([o. đệm, t.data]); return r (s)} chức năng a (t) {thử {t = d.decode (t, {rict :! 1})} Catch (e) {return! 1} return t} hàm c (t, e, n) {for (var r = new Array (t.length), o = l (t.length, n), i = function (t, n, o) {e (n, function (e, n) {r [t] = n, o (e, r)})}, s = 0; s <t.length; s ++) i (s, t [s], o)} var u, p = n (22), h = n (23), f = n (24), l = n (25), d = n (26); t && t.ArrayBuffer && (u = n (28)); var y = "không xác định"! = typeof navigator && / Android / i.test (navigator.userAgent), m = "không xác định "! = typeof navigator && / PhantomJS / i.test (navigator.userAgent), g = y || m; e.protatio = 3; var v = e.packets = {open: 0, close: 1, ping: 2 , pong: 3, tin nhắn: 4, nâng cấp: 5, noop: 6}, b = p (v), w = {type: "error", data: "lỗi trình phân tích cú pháp"}, k = n (29); e .encodePacket = function (e, n, i, a) {"function" == typeof n && (a = n, n =! 1), "function" == typeof i && (a = i, i = null); var c = void 0 === e.data?void 0: e.data.buffer || e.data; if (t.ArrayBuffer && c instanceof ArrayBuffer) return o (e, n, a); if (k && c instanceof t.Blob ) return s (e, n, a); if (c && c.base64) return r (e, a); var u = v [e.type]; return void 0! == e.data && (u + = i? d .encode (Chuỗi (e.data), {rict :! 1}): Chuỗi (e.data)), a ("" + u)}, e.encodeBase64Packet = function (n, r) {var o = " b "+ e.packets [n.type]; if (k && n.data instanceof t.Blob) {var i = new FileReader; return i.onload = function () {var t = i.result.split (",") [1]; r (o + t)}, i.readAsDataURL (n.data)} var s; thử {s = String.fromCharCode .apply (null, Uint8Array (n.data))} Catch (a) {for (var c = new Uint8Array (n.data), u = new Array (c.length), p = 0; p <c. length; p ++) u [p] = c [p]; s = String.fromCharCode.apply (null, u)} return o + = t.btoa (s), r (o)}, e.decodePacket = function (t , n, r) {if (void 0 === t) return w; if ("string" == typeof t) {if ("b" === t.charAt (0)) return e.decodeBase64Packet (t .substr (1), n); if (r && (t = a (t), t ===! 1)) return w; var o = t.charAt (0); return Number (o) == o && b [ o]? t.length> 1? {type: b [o], data: t.subopes (1)}: {type: b [o]}: w} var i = new Uint8Array (t), o = i [0], s = f (t, 1); return k && "blob" === n && (s = new k ([s])), {type: b [o], data: s}}, e. decodeBase64Packet = function (t, e) {var n = b [t.charAt (0)]; if (! u) return {type: n, data: {base64 :! 0, data: t.substr (1)} };var r = u.decode (t.substr (1)); trả về "blob" === e && k && (r = new k ([r])), {type: n, data: r}}, e.encodePayload = hàm (t, n, r) {function o (t) {return t.length + ":" + t} chức năng i (t, r) {e.encodePacket (t, !! s && n ,! 1, function (t) {r (null, o (t))})} "function" == typeof n && (r = n, n = null); var s = h (t); return n && s? k &&! g? e.encodePayloadAsBlob (t , r): e.encodePayloadAsArrayBuffer (t, r): t.length? void c (t, i, function (t, e) {return r (e.join (""))}): r ("0: ")}, e.decodePayload = function (t, n, r) {if (" chuỗi "! = typeof t) return e.decodePayloadAsBinary (t, n, r);" function "== typeof n && (r = n , n = null); var o; if ("" === t) return r (w, 0,1); for (var i, s, a = "", c = 0, u = t.length; c <u; c ++) {var p = t.charAt (c); if (":" === p) {if ("" === a | | a! = (i = Số (a))) trả về r (w, 0,1); if (s = t.chất nền (c + 1, i), a! = s.length) return r (w, 0,1); if (s.length) {if (o = e.decodePacket (s, n ,! 1), w .type === o.type && w.data === o.data) return r (w, 0,1); var h = r (o, c + i, u); if (! 1 === h) return} c + = i, a = ""} khác a + = p} return ""! == a? r (w, 0,1): void 0}, e.encodePayloadAsArrayBuffer = function (t, n) {function r (t, n) {e.encodePacket (t ,! 0 ,! 0, hàm (t) {return n (null, t)})} return t.length? void c (t, r, function (t, e ) {var r = e.reduce (function (t, e) {var n; return n = "string" == typeof e? e.length: e.byteLpm, t + n.toString (). length + n + 2}, 0), o = new Uint8Array (r), i = 0; return e.forEach (function (t) {var e = "string" == typeof t, n = t; if (e) {for ( var r = new Uint8Array (t.length), s = 0; s <t.length; s ++) r [s] = t.charCodeAt (s); n = r.buffer} e? o [i ++] = 0: o [i ++] = 1; for (var a = n.byteL wavel.toString (), s = 0; s <a.length; s ++) o [i ++] = parseInt (a [s]); o [i ++] = 255; for (var r = new Uint8Array (n), s = 0; s <r.length; s ++) o [i ++] = r [s]}), n (o.buffer)}): n (new ArrayBuffer (0))}, e.encodePayloadAsBlob = function (t, n) {function r (t , n) {e.encodePacket (t ,! 0 ,! 0, hàm (t) {var e = new Uint8Array (1); if (e [0] = 1, "chuỗi" == typeof t) {for ( var r = new Uint8Array (t.length), o = 0; o <t.length; o ++) r [o] = t.charCodeAt (o); t = r.buffer, e [0] = 0} cho ( var i = t instanceof ArrayBuffer? t.byteLpm: t.size, s = i.toString (), a = new Uint8Array (s.length + 1), o = 0; o <s.length; o ++) a [o ] = parseInt (s [o]); if (a [s.length] = 255, k) {var c = new k ([e.buffer, a.buffer, t]); n (null, c)} })} c (t, r, function (t, e) {return n (new k (e))})}, e.decodePayloadAsBinary = function (t, n, r) {"function" == typeof n && ( r = n, n = null); for (var o = t, i = []; o.byteLpm> 0;) {for (var s = new Uint8Array (o), a = 0 === s [0] , c = "", u = 1; 255! == s [u]; u ++) {if (c.length> 310) trả về r (w, 0,1); c + = s [u]} o = f (o, 2 + c.length), c = parseInt (c); var p = f (o, 0, c);if (a) thử {p = String.fromCharCode.apply (null, Uint8Array (p))} Catch (h) {var l = new Uint8Array (p); p = ""; for (var u = 0; u <l.length; u ++) p + = String.fromCharCode (l [u])} i.push (p), o = f (o, c)} var d = i.length; i.forEach (hàm (t, o) {r (e.decodePacket (t, n ,! 0), o, d)})}}). gọi (e, function () {return this} ())}, function (t, e) { t.exports = Object.keys | | function (t) {var e = [], n = Object.prototype.hasOwnProperty; for (var r in t) n.call (t, r) && e.push (r); return e}}, function (t, e, n) {(function (e) {function r (t) {if (! t || "object"! = typeof t) return! 1; if (o (t) ) {for (var n = 0, i = t.length; n <i; n ++) if (r (t [n])) return! 0; return! 1} if ("function" == typeof e.Buffer && e .Buffer.isBuffer && e.Buffer.isBuffer (t) || "function" == typeof e.ArrayBuffer && t instanceof ArrayBuffer || s && t instanceof Blob || a && t instanceof File) return! 0;toJSON && "function" == typeof t.toJSON && 1 === argument.length) return r (t.toJSON (),! 0); for (var c in t) if (Object.prototype.hasOwnProperty.call (t, c ) && r (t [c])) return! 0; return! 1} var o = n (10), i = Object.prototype.toString, s = "function" == typeof e.Blob || "[object BlobConstructor ] "=== i.call (e.Blob), a =" function "== typeof e.File ||" [object FileConstructor] "=== i.call (e.File); t.exports = r }). call (e, function () {return this} ())}, function (t, e) {t.exports = function (t, e, n) {var r = t.byteLpm; if (e = e | | 0, n = n | | r, t.slice) trả về t.slice (e, n); if (e <0 && (e + = r), n <0 && (n + = r), n> r && ( n = r), e> = r || e> = n || 0 === r) trả về ArrayBuffer mới (0); for (var o = new Uint8Array (t), i = new Uint8Array (ne), s = e, a = 0; s <n; s ++, a ++) i [a] = o [s]; return i.buffer}}, function (t, e) {function n (t, e, n) {function o (t, r) {nếu (o.đếm <= 0) ném Lỗi mới ("sau khi gọi quá nhiều lần"); - o.count, t? (i =! 0, e (t), e = n): 0! == o.count | | i | | e (null, r)} var i =! 1; return n = n | | r, o.count = t, 0 === t? e (): o} hàm r () {} t .exports = n}, hàm (t, e, n) {var r; (function (t, o) {! function (i) {function s (t) {for (var e, n, r = [], o = 0, i = t.length; o <i;) e = t.charCodeAt (o ++), e> = 55296 && e <= 56319 && o <i? (n = t.charCodeAt (o ++), 56320 == (64512 & n) ? r.push (((1023 & e) << 10) + (1023 & n) +65536) :( r.push (e), o -)): r.push (e); trả về hàm r} a (t) {for (var e, n = t.length, r = -1, o = ""; ++ r <n;) e = t [r], e> 65535 && (e- = 65536, o + = w (e >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), o + = w (e); trả về o} hàm c (t, e) {if (t> = 55296 && t <= 57343) {if (e) ném Lỗi ("Lone thay thế U +" + t.toString (16) .toUpperCase () + "không phải là giá trị vô hướng"); return! 1} return!Hàm 0} u (t, e) {return w (t >> e & 63 | 128)} hàm p (t, e) {if (0 == (4294967168 & t)) return w (t); var n = ""; trả về 0 == (4294965248 & t)? n = w (t >> 6 & 31 | 192): 0 == (4294901760 & t)? (c (t, e) || (t = 65533), n = w (t >> 12 & 15 | 224), n + = u (t, 6)): 0 == (4292870144 & t) && (n = w (t >> 18 & 7 | 240), n + = u (t, 12), n + = u (t, 6 )), n + = w (63 & t | 128)} hàm h (t, e) {e = e || {}; for (var n, r =! 1! == e.strict, o = s (t) , i = o.length, a = -1, c = ""; ++ a <i;) n = o [a], c + = p (n, r); trả về hàm c} f () {if ( b> = v) throw Error ("Chỉ mục byte không hợp lệ"); var t = 255 & g [b]; if (b ++, 128 == (192 & t)) trả về 63 & t; throw Error ("byte tiếp tục không hợp lệ")} hàm l ( t) {var e, n, r, o, i; if (b> v) throw Error ("Chỉ số byte không hợp lệ"); if (b == v) return! 1; if (e = 255 & g [b], b ++, 0 == (128 & e)) trả về e; if (192 == (224 & e)) {if (n = f (), i = (31 & e) << 6 | n,i> = 128) return i; throw Error ("byte tiếp tục không hợp lệ")} if (224 == (240 & e)) {if (n = f (), r = f (), i = (15 & e) << 12 | n << 6 | r, i> = 2048) return c (i, t)? i: 65533; throw Error ("byte tiếp tục không hợp lệ")} if (240 == (248 & e) && (n = f () , r = f (), o = f (), i = (7 & e) << 18 | n << 12 | r << 6 | o, i> = 65536 && i <= 1114111)) trả lại i; ném Lỗi (" Hàm UTF-8 không hợp lệ được phát hiện ")} hàm d (t, e) {e = e || {}; var n =! 1! == e.strict; g = s (t), v = g.length, b = 0; for (var r, o = []; (r = l (n))! ==! 1;) o.push (r); trả về a (o)} var y = "object" == typeof e && e, m = ("object" == typeof t && t && t.exports == y && t, "object" == typeof o && o); m.global! == m && m.window! == m || (i = m); , v, b, w = String.fromCharCode, k = {phiên bản: "2.1.2", mã hóa: h, giải mã: d}; r = function () {return k} .call (e, n, e, t ) ,!(void 0! == r && (t.exports = r))} (this)}). gọi (e, n (27) (t), function () {return this} ())}, function (t, e) {t.exports = function (t) {return t.webpackPolyfill || (t.deprecate = function () {}, t.paths = [], t.children = [], t.webpackPolyfill = 1), t}}, hàm (t, e) {! function () {"sử dụng nghiêm ngặt"; for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 + /", r ) n [t.charCodeAt (r)] = r; e.encode = function (e) {var n, r = new Uint8Array (e), o = r.length, i = ""; for (n = 0; n <o; n + = 3) i + = t [r [n] >> 2], i + = t [(3 & r [n]) << 4 | r [n + 1] >> 4], i + = t [ (15 & r [n + 1]) << 2 | r [n + 2] >> 6], i + = t [63 & r [n + 2]]; trả về o% 3 === 2? I = i.sub chuỗi ( 0, i.length-1) + "=": o% 3 === 1 && (i = i.sub chuỗi (0, i.length-2) + "=="), i}, e.decode = chức năng (t) {var e, r, o, i, s, a = .75 * t.length, c = t.length, u = 0; "=" === t [t.length-1] && (a -, "=" === t [t.length-2] && a -); var p = new ArrayBuffer (a), h = new Uint8Array (p); for (e = 0; e <c; e + = 4) r = n [t.charCodeAt (e)], o = n [t.charCodeAt (e + 1)], i = n [t.charCodeAt (e + 2)], s = n [t.charCodeAt (e + 3)], h [u ++] = r << 2 | o >> 4, h [u ++] = (15 & o) << 4 | i >> 2, h [u ++] = (3 & i) << 6 | 63 & s; return p}} ()}, hàm (t, e) {(function (e) {function n (t) {for (var e = 0; e <t.length; e ++) {var n = t [e]; if (n.buffer instanceof ArrayBuffer) {var r = n.buffer; if (n.byteL wavel! == r.byteLạng) {var o = new Uint8Array (n.byteLạng) ; o.set (new Uint8Array (r, n.byte Offerset, n.byteLpm)), r = o.buffer} t [e] = r}}} chức năng r (t, e) {e = e || {} ; var r = new i; n (t); for (var o = 0; o <t.length; o ++) r.append (t [o]); trả lại e.type? r.getBlob (e.type) : r.getBlob ()} chức năng o (t, e) {return n (t), Blob mới (t, e | | {})} var i = e.BlobBuilder || e.WebKitBlobBuilder || e.MSBlobBuilder | | e.MozBlobBuilder, s = function () {thử {var t = new Blob (["hi"]); return 2 === t.size} Catch (e) {return! 1}} (), a = s && function () {thử {var t = new Blob ([new Uint8Array ([1,2])]); return 2 === t.size} Catch (e) {return! 1}} (), c = i && i.prototype. chắp thêm && i.prototype.getBlob; t.exports = function () {return s? a? e.Blob: o: c? r: void 0} ()}). call (e, function () {return this} () )}, hàm (t, e) {e.encode = function (t) {var e = ""; for (var n in t) t.hasOwnProperty (n) && (e.length && (e + = "&") , e + = encodeURIComponent (n) + "=" + encodeURIComponent (t [n])); return e}, e.decode = function (t) {for (var e = {}, n = t.split ("& "), r = 0, o = n.length; r <o; r ++) {var i = n [r] .split (" = "); e [decodeURIComponent (i [0])] = decodeURIComponent (i [ 1])} return e}}, function (t, e) {t.exports = function (t, e) {var n = function () {}; n.prototype = e.prototype, t.nguyên mẫu = new n, t.prototype.constructor = t}}, function (t, e) {"sử dụng nghiêm ngặt"; function n (t) {var e = ""; do e = s [t% a] + e , t = Math.floor (t / a); while (t> 0); trả về hàm e} r (t) {var e = 0; for (p = 0; p <t.length; p ++) e = e * a + c [t.charAt (p)]; return e} hàm o () {var t = n (+ ngày mới); return t! == i? (u = 0, i = t): t + " . "+ n (u ++)} for (var i, s =" 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz -_ ". split (" "), a = 64, p = c [s [p]] = p; o.encode = n, o.decode = r, t.exports = o}, hàm (t, e, n) {(function (e) {function r () {} hàm o (t) {i.call (this, t), this.query = this.query || {}, a || (e .___ eio || (e .___ eio = []), a = e .___ eio ), this.index = a.length; var n = this; a.push (function (t) {n.onData (t)}), this.query.j = this.index, e.document && e.addEventListener && e.addEventListener ("tải trước", hàm () {n.script && (n.script.onerror = r)},! 1)} var i = n (19), s = n (31); t.exports = o; var a, c = / \ n / g, u = / \\ n /g;s(o,i),o.prototype.supportsBinary=!1,o.prototype.doClose=feft() ndthis.script&&(this.script.parentNode.removeChild(this.script),this.script= null), this.form && (this.form.parentNode.removeChild (this.form), this.form = null, this.iframe = null), i.prototype.doClose.call (this)}, o.prototype.doPoll = function () {var t = this, e = document.createEuity ("script"); this.script && (this.script.parentNode.removeChild (this.script), this.script = null), e.async =! 0, e.src = this.uri (), e.onerror = function (e) {t.onError ("jsonp poll error", e)}; var n = document.getElementsByTagName ("script") [0]; n? n.parentNode.insertB Before (e, n) :( document.head || document.body) .appendChild (e), this.script = e; var r = "undinite"! = typeof navigator && / gecko / i.test (navigator.userAgent); r && setTimeout (function () {var t = document.createEuity ("iframe"); document.body.appendChild (t), document.body.removeChild (t)}, 100)}, o. nguyên mẫu.doWrite = function (t, e) {function n () {r (), e ()} chức năng r () {if (o.iframe) thử {o.form.removeChild (o.iframe)} Catch ( t) {o.onError ("lỗi loại bỏ iframe bỏ phiếu", t)} thử {var e = '<iframe src = "javascript: 0" name = "' + o.iframeId + '">'; i = document. createdEuity (e)} Catch (t) {i = document.createEuity ("iframe"), i.name = o.iframeId, i.src = "javascript: 0"} i.id = o.iframeId, o.form .appendChild (i), o.iframe = i} var o = this; if (! this.form) {var i, s = document.createEuity ("form"), a = document.createEuity ("textarea"), p = this.iframeId = "eio_iframe _" + this.index; s. className = "socketio", s.style.vị trí = "tuyệt đối", s.style.top = "- 1000px", s.style.left = "- 1000px", s.target = p, s.method = "POST", s.setAttribution ("accept-charset "," utf-8 "), a.name =" d ", s.appendChild (a), document.body.appendChild (s), this.form = s, this.area = a} this.form.action = this.uri (), r (), t = t.replace (u, "\\\ n"), this.area.value = t.replace (c, "\\ n"); hãy thử {this. form.submit ()} Catch (h) {} this.iframe.attachEvent? this.iframe.onreadystatechange = function () {"Complete" === o.iframe. yetState && n ()}: this.iframe.onload = n }}). call (e, function () {return this} ())}, function (t, e, n) {(function (e) {function r (t) {var e = t && t.forceBase64; e && ( this.supportsBinary =! 1), this.perMessageDeflate = t.perMessageDeflate, this.USEBrowserWebSocket = h &&! t.forceNode, this.prot Protocol = t.prot Protocol, this.bằng cách sử dụngBrowserWebSocket || (l = o), i.call (this, t)} var o, i = n (20), s = n (21), a = n (30), c = n (31), u = n (32), p = n (3) ("engine.io-client: websocket"), h = e.WebSocket || e.MozWebSocket; if ("không xác định" == cửa sổ typeof) thử {o = n (35)} Catch (f) {} var l = h; l || "không xác định"! = Typeof window || (l = o), t.exports = r, c (r, i), r.prototype. name = "websocket", r.prototype.supportsBinary =! 0, r.prototype.doOpen = function () {if (this.check ()) {var t = this.uri (), e = this.prot Protocol, n = {agent: this.agent, perMessageDeflate: this.perMessageDeflate}; n.pfx = this.pfx, n.key = this.key, n.passphrase = this.passphrase, n.cert = this.cert, n.ca = this.ca, n.ciphers = this.ciphers, n.rejectUnauthorized = this.rejectUnauthorized, this.extraHeaders && (n.headers = this.extraHeaders), this.localAddress && (n.localAddress .ws = this.USEBrowserWebSocket? e? new l (t, e): new l (t): new l (t,e, n)} Catch (r) {return this.emit ("error", r)} void 0 === this.ws.binaryType && (this.supportsBinary =! 1), this.ws.supports && this.ws.supports .binary? (this.supportsBinary =! 0, this.ws.binaryType = "gật đầu"): this.ws.binaryType = "mảngbuffer", this.addEventListener ()}}, r.prototype.addEventListener = function () var t = this; this.ws.onopen = function () {t.onOpen ()}, this.ws.onclose = function () {t.onClose ()}, this.ws.onmessage = function (e) { t.onData (e.data)}, this.ws.onerror = function (e) {t.onError ("lỗi websocket", e)}}, r.prototype.write = function (t) {function n () {r.emit ("flush"), setTimeout (function () {r.writable =! 0, r.emit ("Drain")}, 0)} var r = this; this.writable =! 1; for ( var o = t.length, i = 0, a = o; i <a; i ++)! function (t) {s.encodePacket (t, r.supportsBinary, function (i) {if (! r.USEBrowserWebSocket) { var s = {}; if (t.tùy chọn && (s.compress = t.options.compress), r.perMessageDeflate) {var a = "string" == typeof i? e.Buffer.byteLpm (i): i.length; a <r.perMessageDeflate.thr & s.compress =! 1)}} hãy thử {r.USEBrowserWebSocket? r.ws.send (i): r.ws.send (i, s)} Catch (c) {p ("websocket đã đóng trước sự kiện onclose") } - o || n ()})} (t [i])}, r.prototype.onClose = function () {i.prototype.onClose.call (this)}, r.prototype.doClose = function ( ) {"không xác định"! = typeof this.ws && this.ws.close ()}, r.prototype.uri = function () {var t = this.query || {}, e = this.secure? "wss": "ws", n = ""; this.port && ("wss" === e && 443! == Số (this.port) || "ws" === e && 80! == Số (this.port)) && ( n = ":" + this.port), this.timestampRequests && (t [this.timestampParam] = u ()), this.supportsBinary || (t.b64 = 1), t = a.mã hóa (t), t.length && (t = "?" + t); var r = this.hostname.indexOf (":")! == - 1; return e + ": //" + (r? "[ "+ this.hostname +"] ": this.hostname) + n + this.path + t}, r.prototype.check = function () {return! (! l ||" __ khởi tạo "trong l && this.name === r.prototype.name)}}). call (e, function () {return this} ())}, function (t, e) {}, function (t, e) {var n = []. indexOf; t.exports = function (t, e) {if (n) return t.indexOf (e); for (var r = 0; r <t.length; ++ r) if (t [r] === e ) return r; return-1}}, function (t, e, n) {"userict"; function r (t, e, n) {this.io = t, this.nsp = e, this.json = this, this.ids = 0, this.acks = {}, this.receiveBuffer = [], this.sendBuffer = [], this.connected =! 1, this.disconnected =! 0, this.flags = {}, n && n.query && (this.query = n.query), this.io.autoConnect && this.open ()} var o = "function" == typeof Symbol && "biểu tượng "== typeof Symbol.iterator? function (t) {return typeof t}: function (t) {return t &&" function "== typeof Symbol && t.constructor === Symbol && t! == Symbol.prototype?" Symbol ": typeof t}, i = n (7), s = n (8), a = n (38), c = n (39), u = n (40), p = n (3) ("socket.io -client: socket "), h = n (30), f = n (23); t.exports = e = r; var l = {connect: 1, connect_error: 1, connect_timeout: 1, kết nối: 1, ngắt kết nối : 1, lỗi: 1, kết nối lại: 1, kết nối lại: 1, kết nối lại: 1, kết nối lại: 1, kết nối lại: 1, ping: 1, pong: 1}, d = s.prototype.emit; s (r.prototype) , r.prototype.subEvents = function () {if (! this.sub) {var t = this.io; this.sub = [c (t, "open", u (this, "onopen")), c (t, "gói", u (này, "onpacket")), c (t, "đóng", u (này, "onclose"))]}}, r.prototype.open = r.prototype.connect = function () {return this.connected? this:(this.subEvents (), this.io.open (), "open" === this.io. yetState && this.onopen (), this.emit ("kết nối"), this)}, r.prototype.send = function () {var t = a (argument); return t.unshift ("message"), this.emit.apply (this, t), this}, r.prototype.emit = function (t) {if (l .hasOwnProperty (t)) return d.apply (this, argument), this; var e = a (argument), n = {type: (void 0! == this.flags.binary? this.flags.binary: f (e))? i.BINARY_EVENT: i.EVENT, dữ liệu: e}; return n.options = {}, n.options.compress =! this.flags ||! 1! == this.flags.compress, " hàm "== typeof e [e.length-1] && (p (" phát gói tin với ack id% d ", this.ids), this.acks [this.ids] = e.pop (), n.id = this.ids ++), this.connected? this.pquet (n): this.sendBuffer.push (n), this.flags = {}, this}, r.prototype.pquet = function (t) {t.nsp = this.nsp, this.io.pquet (t)}, r.prototype.onopen = function () {if (p ("vận chuyển là mở - kết nối ")," / "! == this.nsp) if (this.query) {var t =" object "=== o (this.query)? h.encode (this.query): this.query; p ("gửi gói kết nối với truy vấn% s", t), this.pquet ({type: i.CONNECT, truy vấn: t})} other this.pquet ({type: i.CONNECT})} , r.prototype.onclose = function (t) {p ("close (% s)", t), this.connected =! 1, this.disconnected =! 0, xóa this.id, this.emit ("disconnect ", t)}, r.prototype.onpacket = function (t) {var e = t.nsp === this.nsp, n = t.type === i.ERROR &&" / "=== t.nsp ; if (e || n) switch (t.type) {case i.CONNECT: this.onconnect (); break; case i.EVENT: this.onevent (t); break; case i.BINARY_EVENT: this.onevent (t); break; case i.ACK: this.onack (t); break; case i.BINARY_ACK: this.onack (t); break; case i.DISCONNECT: this.ondisconnect (); break; case i. LRI: this.emit ("lỗi", t.data)}}, r.prototype.onevent = function (t) {var e = t.data || []; p ("phát ra sự kiện% j", e), null! = t.id && (p ("đính kèm gọi lại ack vào sự kiện"), e. đẩy (this.ack (t.id))), this.connected? d.apply (this, e): this.receiveBuffer.push (e)}, r.prototype.ack = function (t) {var e = this, n =! 1; Hàm trả về () {if (! n) {n =! 0; var r = a (argument); p ("gửi ack% j", r), e.pquet ({type: f (r)? i.BINARY_ACK: i.ACK, id: t, data: r})}}}, r.prototype.onack = function (t) {var e = this.acks [t.id]; " hàm "== typeof e? (p (" gọi ack% s bằng% j ", t.id, t.data), e.apply (this, t.data), xóa this.acks [t.id]) : p ("bad ack% s", t.id)}, r.prototype.onconnect = function () {this.connected =! 0, this.disconnected =! 1, this.emit ("connect"), this .emitBuffered ()}, r.prototype.emitBuffered = function () {var t; for (t = 0; t <this.receiveBuffer.length; t ++) d.apply (this, this.receiveBuffer [t]);for (this.receiveBuffer = [], t = 0; t <this.sendBuffer.length; t ++) this. () {p ("ngắt kết nối máy chủ (% s)", this.nsp), this.destroy (), this.onclose ("io server disconnect")}, r.prototype.destroy = function () {if (this .sub) {for (var t = 0; t <this.sub.length; t ++) this.sub [t] .destroy (); this.sub = null} this.io.destroy (this)}, r. nguyên mẫu.clc = .destroy (), this. hàm (t) {return this.flags.binary = t, this}}, function (t, e) {function n (t, e) {var n = []; e = e || 0; for (var r = e | | 0;r <t.length; r ++) n [re] = t [r]; return n} t.exports = n}, function (t, e) {"sử dụng nghiêm ngặt"; function n (t, e, n) { return t.on (e, n), {hủy: function () {t.removeListener (e, n)}}} t.exports = n}, function (t, e) {var n = []. lát; t.exports = function (t, e) {if ("chuỗi" == typeof e && (e = t [e]), "function"! = typeof e) ném Lỗi mới ("bind () yêu cầu hàm") ; var r = n.call (argument, 2); return function () {return e.apply (t, r.concat (n.call (argument)))}}}, function (t, e) {function n (t) {t = t || {}, this.ms = t.min || 100, this.max = t.max | | 1e4, this.factor = t.factor || 2, this.jitter = t .jitter> 0 && t.jitter <= 1? t.jitter: 0, this.attvor = 0} t.exports = n, n.prototype.duration = function () {var t = this.ms * Math.pow (this .factor, this.attvor ++); if (this.jitter) {var e = Math.random (), n = Math.floor (e * this.jitter * t); t = 0 == (1 & Math.floor (10 * e))? tn: t + n} trả về 0 | Math.min (t,this.max)}, n.prototype.reset = function () {this.attvor = 0}, n.prototype.setMin = function (t) {this.ms = t}, n.prototype.setMax = function (t ) {this.max = t}, n.prototype.setJitter = function (t) {this.jitter = t}}])});
// # sourceMappingURL = socket.io.js.map